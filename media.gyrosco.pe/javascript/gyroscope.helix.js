// Generated by CoffeeScript 1.10.0
(function() {
  var stuff;

  window.HelixAbout = (function() {
    function HelixAbout() {}

    HelixAbout.prototype.init = function() {
      return gyroscope.aileron.timeouts.push(timeoutSet(950, function() {
        return gyroscope.extras.startIncrementingAge();
      }));
    };

    return HelixAbout;

  })();

  window.GyroscopeHelix = (function() {
    function GyroscopeHelix() {
      this.helpers = new HelixHelpers();
      this.bindKeystrokes();
      this.home = new HelixHome(this.helpers);
      this.about = new HelixAbout(this.helpers);
      this.brain = new HelixBrain(this.helpers);
      this.heart = new HelixHeart(this.helpers);
      this.core = new HelixCore(this.helpers);
      this.legs = new HelixLegs(this.helpers);
      this.feet = new HelixFeet(this.helpers);
      this.body = new HelixBody();
      this.body.bindBody();
      this.body.runScan();
      L.mapbox.accessToken = 'pk.eyJ1IjoiZ3lyb3Njb3BlIiwiYSI6ImNQb0ZFQXMifQ.02b2nGQcu4-DYKSyYsenHg';
      if (($('.twitter-button').length)) {
        timeoutSet(800, (function(_this) {
          return function() {
            return _this.loadTwitterJs();
          };
        })(this));
      }
      if (($('.facebook-button').length)) {
        timeoutSet(1000, (function(_this) {
          return function() {
            return _this.loadFacebookJs();
          };
        })(this));
      }
    }

    GyroscopeHelix.prototype.init = function(section, page) {
      if (section === 'home') {
        this.home.init();
        return this.enterHome();
      } else if (section === 'about') {
        this.about.init();
        return this.leaveContent();
      } else {
        this.helpers.showGlow();
        this.enterContent();
        if (section === 'brain') {
          return this.brain.init();
        } else if (section === 'heart') {
          return this.heart.init();
        } else if (section === 'core') {
          return this.core.init();
        } else if (section === 'legs') {
          return this.legs.init();
        } else if (section === 'feet') {
          return this.feet.init();
        }
      }
    };

    GyroscopeHelix.prototype.cleanup = function(section, page) {
      if (section === 'home') {
        return this.home.cleanup();
      }
    };

    GyroscopeHelix.prototype.enterHome = function() {
      $('.page-container,.globals').addClass('in-home').removeClass('in-content');
      return this.helpers.startAge();
    };

    GyroscopeHelix.prototype.enterContent = function() {
      $('.page-container,.globals').removeClass('in-home').addClass('in-content');
      this.helpers.startAge();
      return this.showGauges();
    };

    GyroscopeHelix.prototype.leaveContent = function() {
      return $('.page-container,.globals').removeClass('in-content').removeClass('in-home');
    };

    GyroscopeHelix.prototype.showGauges = function() {
      var gauges, initial, preloaded;
      preloaded = $('.page-container').hasClass('scanned');
      initial = preloaded ? -180 : 1200;
      gauges = $('#page .gauges');
      if (!gauges.length) {
        return;
      }
      timeoutSet(190 + initial, function() {
        return gauges.addClass('active');
      });
      return $('.gauge', gauges).each((function(_this) {
        return function(n, el) {
          var gauge;
          gauge = $(el);
          return timeoutSet(initial + n * 210, function() {
            return gauge.removeClass('not-showing').addClass('showing');
          });
        };
      })(this));
    };

    GyroscopeHelix.prototype.bindKeystrokes = function() {
      return $(window).on('keydown', (function(_this) {
        return function(e) {
          if (e.which === 37) {
            if (gyroscope.aileron.currentSection === 'home') {
              if (_this.home.canSwitchDay()) {
                e.preventDefault();
                if (_this.home.scrollLock) {
                  return;
                }
                return _this.home.switchDay(-1);
              }
            }
          } else if (e.which === 39) {
            if (gyroscope.aileron.currentSection === 'home') {
              if (_this.home.canSwitchDay()) {
                e.preventDefault();
                if (_this.home.scrollLock) {
                  return;
                }
                return _this.home.switchDay(1);
              }
            }
          } else if (e.which === 27) {
            if (gyroscope.aileron.currentSection === 'home') {
              return;
            }
            if ($('body').hasClass('expanded')) {
              return $('body').removeClass('expanded');
            }
          }
        };
      })(this));
    };

    GyroscopeHelix.prototype.loadFacebookJs = function() {
      var el;
      el = '<div id="fb-root"></div>\n<script>(function(d, s, id) {\n  var js, fjs = d.getElementsByTagName(s)[0];\n  if (d.getElementById(id)) return;\n  js = d.createElement(s); js.id = id;\n  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=309431422557180&version=v2.9";\n  fjs.parentNode.insertBefore(js, fjs);\n}(document, \'script\', \'facebook-jssdk\'));</script>';
      return $('#page').append(el);
    };

    GyroscopeHelix.prototype.loadTwitterJs = function() {
      return $('#page').append('<script async src="//platform.twitter.com/widgets.js" charset="utf-8" />');
    };

    return GyroscopeHelix;

  })();

  window.HelixBody = (function() {
    function HelixBody() {}

    HelixBody.prototype.bindBody = function() {
      $(document).on('mouseenter', '.body .actions a, .human-nav a', (function(_this) {
        return function(e) {
          var container, link, name, navitem, part;
          link = $(e.currentTarget);
          part = link.parents('li');
          name = part.attr('data-name');
          if (!name) {
            return;
          }
          container = $('.page-container .human');
          container.removeClass('hover-brain hover-heart hover-core hover-legs hover-feet');
          container.addClass('hover-' + name);
          $('.human-nav .hovering').removeClass('hovering');
          return navitem = $('.human-nav .' + name + ' a').addClass('hovering');
        };
      })(this));
      return $(document).on('mouseleave', '.body .actions a, .human-nav a', (function(_this) {
        return function(e) {
          var container, link, name, part;
          link = $(e.currentTarget);
          part = link.parents('li');
          name = part.attr('data-name');
          if (!name) {
            return;
          }
          container = $('.page-container .human');
          container.removeClass('hover-brain hover-heart hover-core hover-legs hover-feet');
          return $('.human-nav .hovering').removeClass('hovering');
        };
      })(this));
    };

    HelixBody.prototype.runScan = function() {
      return timeoutSet(144, function() {
        var bodyEl, human;
        bodyEl = $('.page-container').addClass('scanning');
        human = $('.human.hidden').addClass('revealing');
        timeoutSet(5, function() {
          return human.removeClass('hidden');
        });
        timeoutSet(1100, function() {
          human.addClass('scanned');
          return bodyEl.addClass('scanned');
        });
        return timeoutSet(2600, function() {
          return human.removeClass('revealing').addClass('hoverable');
        });
      });
    };

    HelixBody.prototype.rescan = function() {
      var human;
      human = $('.human');
      if (!human.hasClass('scanned')) {
        return;
      }
      human.removeClass('scanning scanned');
      return this.runScan();
    };

    return HelixBody;

  })();

  window.HelixBrain = (function() {
    function HelixBrain(helpers) {
      this.helpers = helpers;
      this.bindLegend();
      this.bindSeeMore();
    }

    HelixBrain.prototype.init = function() {
      var initial, preloaded;
      preloaded = $('.page-container').hasClass('scanned');
      initial = preloaded ? -80 : 1200;
      return this.buildDays(initial);
    };

    HelixBrain.prototype.buildDays = function(initial) {
      var labels, title;
      labels = $('.timelines .day-labels');
      title = $('.timelines .title');
      timeoutSet(200 + initial, function() {
        return labels.addClass('showing');
      });
      timeoutSet(initial + 200, function() {
        return title.addClass('showing');
      });
      return $('.page .days .day').each((function(_this) {
        return function(n, el) {
          var day;
          day = $(el);
          if (day.css('display') !== 'block') {
            return;
          }
          timeoutSet(initial + 450 + n * 240, function() {
            return day.addClass('showing');
          });
          return _this.helpers.loadBrainLine($('.brainline', day));
        };
      })(this));
    };

    HelixBrain.prototype.bindSeeMore = function() {
      return $(document).on('click', '.brain-content .more-days', (function(_this) {
        return function(e) {
          e.preventDefault();
          $('body').addClass('expanded');
          return $('.page .days .day').each(function(n, el) {
            var day;
            day = $(el);
            timeoutSet(-300 + n * 280, function() {
              if (day.css('display') === 'block') {
                return day.addClass('showing');
              }
            });
            return timeoutSet(-300 + n * 120, function() {
              return _this.helpers.loadBrainLine($('.brainline', day));
            });
          });
        };
      })(this));
    };

    HelixBrain.prototype.bindLegend = function() {
      $(document).on('mouseenter', '.brain-content .legend .item', (function(_this) {
        return function(e) {
          var el, type;
          el = $(e.currentTarget);
          type = el.attr('data-type');
          return _this.startHover(type);
        };
      })(this));
      return $(document).on('mouseleave', '.brain-content .legend .item', (function(_this) {
        return function(e) {
          var el, type;
          el = $(e.currentTarget);
          type = el.attr('data-type');
          return _this.endHover(type);
        };
      })(this));
    };

    HelixBrain.prototype.startHover = function(type) {
      if (!type) {
        return;
      }
      return $('body').removeClass('hover-unproductive hover-productive hover-music hover-commit').addClass('hover-legend hover-' + type);
    };

    HelixBrain.prototype.endHover = function(type) {
      if (!type) {
        return;
      }
      return $('body').removeClass('hover-legend hover-unproductive hover-productive hover-music hover-commit');
    };

    return HelixBrain;

  })();

  window.HelixCore = (function() {
    function HelixCore(helpers) {
      this.helpers = helpers;
      this.bindWeightToggle();
    }

    HelixCore.prototype.init = function() {
      var toggle, url;
      this.graph = $('#page .weightgraph');
      toggle = $('#page .graph-toggle .switch-weight.selected');
      url = toggle.attr('href');
      if (url) {
        return this.populateGraphWithDataUrl(url);
      }
    };

    HelixCore.prototype.bindWeightToggle = function() {
      return $(document).on('click', '.graph-toggle .switch-weight', (function(_this) {
        return function(e) {
          var button, url;
          e.preventDefault();
          button = $(e.currentTarget);
          if (button.hasClass('selected')) {
            return;
          }
          url = button.attr('href');
          if (!url) {
            return;
          }
          $('#page .graph-toggle .switch-weight').removeClass('selected');
          button.addClass('selected');
          _this.cleanupGraph();
          return _this.populateGraphWithDataUrl(url);
        };
      })(this));
    };

    HelixCore.prototype.populateGraphWithDataUrl = function(url) {
      return this.helpers.buildWeightGraph(this.graph, url);
    };

    HelixCore.prototype.showGraph = function() {
      return this.graph.addClass('showing');
    };

    HelixCore.prototype.cleanupGraph = function() {
      this.graph.find('.weight.pathline.removing').remove();
      this.graph.find('.weight.pathline').attr('class', 'weight pathline removing');
      return this.graph.removeClass('showing');
    };

    return HelixCore;

  })();

  window.HelixFeet = (function() {
    function HelixFeet() {}

    HelixFeet.prototype.init = function() {
      L.mapbox.accessToken = 'pk.eyJ1IjoiZ3lyb3Njb3BlIiwiYSI6ImNQb0ZFQXMifQ.02b2nGQcu4-DYKSyYsenHg';
      return this.initVisits();
    };

    HelixFeet.prototype.initVisits = function(tiles) {
      var bottom_transports_layer, i, j, k, len, len1, len2, map_style, motion, paddingMap, places, points, results, top_transports_layer, travel_points_in_range;
      points = [];
      places = [];
      travel_points_in_range = [];
      $('#page .visits-overlay .visit').each((function(_this) {
        return function(n, el) {
          var lat, long, visit;
          visit = $(el);
          lat = visit.attr('data-latitude');
          long = visit.attr('data-longitude');
          if (lat && long) {
            return points.push([lat, long]);
          }
        };
      })(this));
      map_style = tiles || 'gyroscope.k8ga08k9';
      paddingMap = [88, 24, 32, 24];
      if ($('html').hasClass('mobile')) {
        paddingMap = [55, 8, 10, 8];
      }
      this.createMap(map_style, 'visit-map', points, 0.55, paddingMap, 8, 16);
      $('#page .visits-overlay .visit').each((function(_this) {
        return function(n, el) {
          var lat, latlong, long, position, visit;
          visit = $(el);
          lat = visit.attr('data-latitude');
          long = visit.attr('data-longitude');
          latlong = L.latLng(lat, long);
          position = _this.map.latLngToContainerPoint(latlong);
          return visit.css({
            top: position.y,
            left: position.x
          });
        };
      })(this));
      timeoutSet(150, function() {
        return $('#page .visits-overlay .visit').addClass('prepped');
      });
      timeoutSet(250, function() {
        return $('#page .visits-overlay .visit').removeClass('new');
      });
      bottom_transports_layer = [];
      top_transports_layer = [];
      if (travel_points) {
        this.runCounts = 0;
        this.bikeCounts = 0;
        this.walkCounts = 0;
        this.carCounts = 0;
        for (i = 0, len = travel_points.length; i < len; i++) {
          motion = travel_points[i];
          if (motion.type === 'run') {
            this.tracked_run = true;
            this.runCounts += 1;
          } else if (motion.type === 'bike') {
            this.tracked_bike = true;
            this.bikeCounts += 1;
          } else if (motion.type === 'travel') {
            if (motion.activity === 'walking') {
              this.bikeCounts = 1;
            } else if (motion.activity === 'running') {
              if (!this.tracked_run) {
                this.runCounts += 1;
              }
            } else if (motion.activity === 'cycling') {
              if (!this.tracked_bike) {
                this.bikeCounts += 1;
              }
            } else {
              this.carCounts += 1;
            }
          }
          if (motion.type === 'travel' && (motion.activity === 'transport' || motion.activity === 'car')) {
            bottom_transports_layer.push(motion);
          } else {
            top_transports_layer.push(motion);
          }
        }
        for (j = 0, len1 = bottom_transports_layer.length; j < len1; j++) {
          motion = bottom_transports_layer[j];
          this.buildBrightMotionLine(motion, true);
        }
        results = [];
        for (k = 0, len2 = top_transports_layer.length; k < len2; k++) {
          motion = top_transports_layer[k];
          results.push(this.buildBrightMotionLine(motion, true));
        }
        return results;
      }
    };

    HelixFeet.prototype.createMap = function(map_style, map_id, points, opacity, padding, minZoom, maxZoom) {
      var bottom_padding, bounds, bounds_options, i, lat, latlong, latlongs, left_padding, len, lon, map_options, point, right_padding, top_padding;
      minZoom = minZoom || 10;
      maxZoom = maxZoom || 20;
      if (!padding || (padding.length !== 4)) {
        padding = [20, 32, 56, 32];
      }
      if (map_style === 'none') {
        map_style = false;
      }
      map_options = {
        keyboard: false,
        dragging: false,
        touchZoom: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        tap: false,
        zoomControl: false,
        attributionControl: false,
        noWrap: true,
        featureLayer: false,
        maxZoom: maxZoom,
        minZoom: minZoom
      };
      this.map = L.mapbox.map(map_id, map_style, map_options);
      latlongs = [];
      for (i = 0, len = points.length; i < len; i++) {
        point = points[i];
        lat = point[0];
        lon = point[1];
        latlong = L.latLng(lat, lon);
        latlongs.push(latlong);
      }
      bounds = L.latLngBounds(latlongs);
      top_padding = padding[0];
      right_padding = padding[1];
      bottom_padding = padding[2];
      left_padding = padding[3];
      bounds_options = {
        paddingTopLeft: [left_padding, top_padding],
        paddingBottomRight: [right_padding, bottom_padding]
      };
      this.map.fitBounds(bounds, bounds_options);
      if (this.zoom) {
        $('body').removeClass('mapzoom-' + this.zoom);
      }
      this.zoom = this.map.getZoom();
      $('body').addClass('mapzoom-' + this.zoom);
      return $('.leaflet-tile-pane').css('opacity', opacity);
    };

    HelixFeet.prototype.buildBrightMotionLine = function(motion, greyscale) {
      var color, opacity, smoothing, stroke;
      smoothing = 0;
      if (motion.type === 'run' || motion.type === 'bike') {
        stroke = 1.3;
        if (motion.type === 'run') {
          color = '#18a43c';
          opacity = 5 / this.runCounts;
        } else {
          color = '#e87c12';
          opacity = 5 / this.bikeCounts;
        }
        opacity = Math.min(0.7, opacity);
        if (this.zoom > 10) {
          stroke = stroke * ((this.zoom - 11) / 2.8);
          opacity = opacity / ((this.zoom - 11) / 1.1);
        }
        smoothing = 1;
        if (this.zoom < 12) {
          smoothing = 2;
        }
      } else if (motion.type === 'travel') {
        if (motion.activity === 'walking') {
          color = 'rgba(70,160,180,0.75)';
          stroke = 0.8;
          opacity = 2.5 / this.walkCounts;
          opacity = Math.max(0.1, opacity);
          opacity = Math.min(0.35, opacity);
          if (parseInt(motion.steps) > 1000) {
            opacity = opacity * 1.1;
          }
          if (parseInt(motion.steps) > 2500) {
            opacity = opacity * 1.15;
          }
          if (parseInt(motion.steps) > 1200) {
            stroke = stroke * 1.2;
          }
          if (this.zoom > 12) {
            stroke = stroke * ((this.zoom - 12) / 1.6);
          }
        } else if (motion.activity === 'running') {
          if (this.tracked_run) {
            return;
          }
          color = '#26ff5e';
          if (greyscale) {
            color = 'rgba(160,235,255,0.4)';
          }
          stroke = 1.8;
          opacity = 0.25;
        } else if (motion.activity === 'cycling') {
          if (this.tracked_bikes) {
            return;
          }
          color = '#ffa133';
          if (greyscale) {
            color = 'rgba(160,235,255,0.4)';
          }
          stroke = 1.6;
          opacity = 2 / this.walkCounts;
          opacity = Math.max(0.08, opacity);
          opacity = Math.min(0.21, opacity);
          if (this.zoom > 12) {
            stroke = stroke * ((this.zoom - 12) / 1.6);
          }
        } else {
          color = '#ff308d';
          color = '#9035de';
          color = '#2347ff';
          if (greyscale) {
            color = 'rgba(135,180,240,0.5)';
          }
          stroke = 1.4;
          opacity = 5 / this.carCounts;
          opacity = Math.min(0.4, opacity);
          opacity = Math.max(0.1, opacity);
          if (this.zoom > 12) {
            stroke = stroke * ((this.zoom - 12) / 1.8);
          }
        }
        opacity = Math.min(0.9, opacity);
        opacity = Math.max(0.08, opacity);
        opacity = opacity * 0.8;
        stroke = Math.min(8, stroke);
      }
      stroke = Math.max(0.33, stroke);
      return this.addMotionPath(motion.points, stroke, color, opacity, smoothing);
    };

    HelixFeet.prototype.addMotionPath = function(points, stroke, color, opacity, smoothing) {
      var line, line_options;
      smoothing = smoothing || 0.1;
      line_options = {
        color: color,
        className: 'motion-line',
        smoothFactor: smoothing,
        weight: stroke,
        opacity: opacity,
        fillOpacity: 1,
        lineCap: 'round'
      };
      line = L.polyline(points, line_options);
      return line.addTo(this.map);
    };

    return HelixFeet;

  })();

  window.HelixHeart = (function() {
    function HelixHeart(helpers) {
      this.helpers = helpers;
      this.bindSeeMore();
    }

    HelixHeart.prototype.init = function() {
      var initial, preloaded;
      preloaded = $('.page-container').hasClass('scanned');
      initial = preloaded ? 400 : 1200;
      return this.buildDays(initial);
    };

    HelixHeart.prototype.buildDays = function(initial) {
      var labels, title;
      labels = $('.timelines .day-labels');
      title = $('.timelines .title');
      timeoutSet(200 + initial, function() {
        return labels.addClass('showing');
      });
      timeoutSet(initial + 200, function() {
        return title.addClass('showing');
      });
      return $('.page .days .day').each((function(_this) {
        return function(n, el) {
          var day;
          day = $(el);
          if (day.css('display') !== 'block') {
            return;
          }
          timeoutSet(initial + 450 + n * 240, function() {
            return day.addClass('showing');
          });
          return timeoutSet(100, function() {
            return _this.helpers.loadHeartLine($('.heartline', day));
          });
        };
      })(this));
    };

    HelixHeart.prototype.bindSeeMore = function() {
      return $(document).on('click', '.heart-content .more-days', (function(_this) {
        return function(e) {
          e.preventDefault();
          $('body').addClass('expanded');
          return $('.page .days .day').each(function(n, el) {
            var day;
            day = $(el);
            timeoutSet(-300 + n * 240, function() {
              if (day.css('display') === 'block') {
                return day.addClass('showing');
              }
            });
            return timeoutSet(-300 + n * 90, function() {
              return _this.helpers.loadHeartLine($('.heartline', day));
            });
          });
        };
      })(this));
    };

    return HelixHeart;

  })();

  window.HelixHelpers = (function() {
    function HelixHelpers() {}

    HelixHelpers.prototype.spinLogo = function() {
      return $('.globals .spinning.logo').removeClass('stopped').addClass('started');
    };

    HelixHelpers.prototype.startAge = function() {
      return gyroscope.aileron.timeouts.push(timeoutSet(1200, function() {
        if ($('html').hasClass('mobile')) {
          return gyroscope.extras.startIncrementingAge($('#page'));
        } else {
          return gyroscope.extras.startIncrementingAge($('.globals'));
        }
      }));
    };

    HelixHelpers.prototype.showGlow = function() {
      var g1, g2, g3;
      g1 = $('.helix-background .glow.one').removeClass('glowing glowing-2 end-glow');
      g2 = $('.helix-background .glow.two').removeClass('glowing glowing-2 end-glow');
      g3 = $('.helix-background .glow.three').removeClass('glowing glowing-2 end-glow');
      return timeoutSet(40, function() {
        g1.addClass('glowing');
        timeoutSet(140, function() {
          return g2.addClass('glowing');
        });
        timeoutSet(300, function() {
          return g3.addClass('glowing');
        });
        return gyroscope.aileron.timeouts.push(timeoutSet(300, function() {
          g1.addClass('glowing-2');
          timeoutSet(140, function() {
            return g2.addClass('glowing-2');
          });
          timeoutSet(300, function() {
            return g3.addClass('glowing-2');
          });
          return gyroscope.aileron.timeouts.push(timeoutSet(900, function() {
            g1.addClass('end-glow');
            timeoutSet(200, function() {
              return g2.addClass('end-glow');
            });
            return timeoutSet(600, function() {
              return g3.addClass('end-glow');
            });
          }));
        }));
      });
    };

    HelixHelpers.prototype.dotRevealCascade = function() {
      var initial, preloaded;
      preloaded = $('.page-container').hasClass('scanned');
      initial = preloaded ? -180 : 800;
      $('.page .day-dots').each(function(d, el) {
        var circles, day;
        day = $(el);
        circles = $('.dots', day);
        timeoutSet(initial + 600 + 320 + d * 480, function() {
          return day.addClass('showing');
        });
        return $('.hour', circles).each(function(h, el) {
          var dot, fill, hour;
          hour = $(el);
          dot = $('.dot', hour);
          dot.css('transition-delay', initial + (d * 480) + (h * 144) + 'ms');
          fill = $('.fill', hour);
          return fill.css('transition-delay', initial + (d * 96) + (h * 16) + 'ms');
        });
      });
      timeoutSet(initial + 500, function() {
        return $('body').addClass('showing-dots');
      });
      return timeoutSet(initial + 300 + 320 + (14 * 320), function() {
        return $('.page .day-dots .dot').attr('style', '');
      });
    };

    HelixHelpers.prototype.loadWeightLine = function(container) {
      var json_url;
      json_url = container.attr('data-url');
      if (!json_url) {
        return;
      }
      return this.buildWeightGraph(container, json_url);
    };

    HelixHelpers.prototype.buildWeightGraph = function(container, json_url) {
      return d3.json(json_url, (function(_this) {
        return function(error, response) {
          if (error) {
            console.warn(error);
          }
          if (response.items.length) {
            _this.graphWeight(container, response.items, response.start, response.end, response.max, response.min);
            _this.labelWeightGraph(container, response.max, response.min);
            return _this.labelTimeAxis(container, response.start, response.end);
          } else {
            return console.log('no items for day');
          }
        };
      })(this));
    };

    HelixHelpers.prototype.labelWeightGraph = function(container, max, min) {
      var metric, units;
      metric = container.attr('data-metric') === 'metric';
      units = ' lbs';
      if (metric) {
        max = max * 0.453592;
        min = min * 0.453592;
        units = ' kg';
      }
      $('.y-axis .max.tick .label', container).text(parseInt(max) + units);
      $('.y-axis .high.tick .label', container).text(parseInt(min + (max - min) * 0.75) + units);
      $('.y-axis .mid.tick .label', container).text(parseInt((max + min) / 2) + units);
      $('.y-axis .low.tick .label', container).text(parseInt(min + (max - min) * 0.25) + units);
      return $('.y-axis .min.tick .label', container).text(parseInt(min) + units);
    };

    HelixHelpers.prototype.labelTimeAxis = function(container, start, end) {
      var diff, end_moment, format_style, hi, lo, mid, start_moment;
      start_moment = moment(start);
      end_moment = moment(end);
      format_style = 'MMM D';
      diff = end_moment.clone().diff(start_moment, 'd');
      if (diff > 100) {
        format_style = 'MMM YYYY';
      } else if (diff > 60) {
        format_style = 'M/D/YY';
      }
      lo = start_moment.clone().add(0.25 * diff, 'd');
      mid = start_moment.clone().add(0.5 * diff, 'd');
      hi = start_moment.clone().add(0.75 * diff, 'd');
      $('.x-axis .max.tick .label', container).text('TODAY');
      $('.x-axis .high.tick .label', container).text(hi.format(format_style));
      $('.x-axis .mid.tick .label', container).text(mid.format(format_style));
      $('.x-axis .low.tick .label', container).text(lo.format(format_style));
      return $('.x-axis .min.tick .label', container).text(start_moment.format(format_style));
    };

    HelixHelpers.prototype.buildStepsLine = function(container, bars) {
      var bar, count, day, days_in_month, delay, draw, duration, el, fill, graph, height, i, j, len, len1, length, line, p, path, points, svg, width, x, y;
      graph = $('.stepsline', container);
      width = graph.width();
      height = graph.height();
      days_in_month = bars.length;
      svg = d3.select('#page #fitnessmonth').select('svg');
      line = d3.svg.line().interpolate('bundle').tension(1.25).x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      points = [];
      for (i = 0, len = bars.length; i < len; i++) {
        bar = bars[i];
        fill = $('.steps-fill', bar);
        if (fill) {
          count = fill.attr('data-steps');
          count = Math.min(count, 20000);
          day = fill.attr('data-day');
          x = (day - 0.5) / (days_in_month - 0.25);
          y = 1 - (count / 19000);
          if (x && y) {
            points.push({
              "x": x * width,
              "y": y * height
            });
          }
        }
      }
      svg.append('linearGradient').attr('id', 'steplinecolor').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
        {
          offset: '5%',
          color: '#c63a4a'
        }, {
          offset: '33%',
          color: '#d5d339'
        }, {
          offset: '55%',
          color: '#1cab30'
        }, {
          offset: '80%',
          color: '#23c7e7'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      svg.append('path').attr('d', line(points)).attr('class', 'steps pathline new');
      delay = 50;
      draw = $('.new.pathline', graph);
      for (p = j = 0, len1 = draw.length; j < len1; p = ++j) {
        path = draw[p];
        length = parseInt(path.getTotalLength());
        duration = Math.max(parseInt(5.2 * length), 800);
        el = $(path).css({
          'stroke': 'url(#steplinecolor)',
          'transition-duration': duration + 'ms',
          'transition-delay': delay + 'ms',
          'stroke-dasharray': length + 10,
          'stroke-dashoffset': length + 10
        });
        delay = delay + duration;
      }
      timeoutSet(300, (function(_this) {
        return function() {
          return container.addClass('showing');
        };
      })(this));
      return timeoutSet(500, (function(_this) {
        return function() {
          var k, len2, results;
          results = [];
          for (p = k = 0, len2 = draw.length; k < len2; p = ++k) {
            path = draw[p];
            results.push(el = $(path).css({
              'stroke-dashoffset': 0
            }));
          }
          return results;
        };
      })(this));
    };

    HelixHelpers.prototype.graphWeight = function(container, items, start, end, max, min) {
      var area, avg, chunk, count, delay, dot, dotfield, dothtml, dots, draw, duration, el, even, first, gradId, height, i, id, isgap, item, j, k, l, last_gap, len, len1, len2, len3, len4, len5, length, line, m, o, p, path, points, ref, segment, segments, sum, svg, weight, width, x, y;
      width = $(container).width();
      height = $(container).height();
      max = parseInt(max);
      min = parseInt(min);
      dotfield = $('.dotfield').empty();
      if (max === min) {
        max = max + 1;
        min = min - 1;
      }
      line = d3.svg.line().interpolate('basis').x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      area = d3.svg.area().interpolate('basis').x(function(d) {
        return d.x;
      }).y0(height).y1(function(d) {
        return d.y;
      });
      id = container.attr('id');
      svg = d3.select('#page #' + id).select('svg');
      gradId = 'weightcolor' + id;
      svg.append('linearGradient').attr('id', gradId).attr('gradientUnits', 'userSpaceOnUse').attr('x1', width).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
        {
          offset: '2%',
          color: '#00ffff'
        }, {
          offset: '45%',
          color: '#005de8'
        }, {
          offset: '89%',
          color: '#1f5270'
        }, {
          offset: '94%',
          color: 'rgba(30,80,110,0.2)'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      last_gap = false;
      first = true;
      even = true;
      segments = [];
      dots = [];
      for (i = 0, len = items.length; i < len; i++) {
        chunk = items[i];
        points = [];
        for (j = 0, len1 = chunk.length; j < len1; j++) {
          item = chunk[j];
          x = (item.time - start) / (end - start);
          count = item.values.length;
          if (count) {
            sum = 0;
            ref = item.values;
            for (k = 0, len2 = ref.length; k < len2; k++) {
              weight = ref[k];
              sum += parseFloat(weight);
              dots.push({
                "x": x,
                "y": (max - parseFloat(weight)) / (max - min)
              });
            }
            avg = parseFloat(sum / count);
            y = (max - avg) / (max - min);
          }
          if (x && y) {
            points.push({
              "x": x * width,
              "y": y * height
            });
          }
        }
        if (points.length) {
          if (last_gap) {
            segments.push({
              type: 'gap',
              points: [last_gap, points[0]]
            });
          }
          segments.push({
            type: 'points',
            points: points
          });
          last_gap = points[points.length - 1];
        }
      }
      dothtml = '';
      for (l = 0, len3 = dots.length; l < len3; l++) {
        dot = dots[l];
        dothtml += '<span class="dot" style="top: ' + dot.y * 100 + '%; left: ' + dot.x * 100 + '%;" />';
      }
      dotfield.append(dothtml);
      for (m = 0, len4 = segments.length; m < len4; m++) {
        segment = segments[m];
        points = segment.points;
        if (segment.type === 'gap') {
          svg.append('path').attr('d', line(points)).attr('class', 'weight pathline gapline new');
        } else {
          svg.append('path').attr('d', line(points)).attr('class', 'weight pathline new');
        }
      }
      delay = 50;
      draw = $('.new.pathline', container);
      for (p = o = 0, len5 = draw.length; o < len5; p = ++o) {
        path = draw[p];
        length = parseInt(path.getTotalLength());
        isgap = $(path).attr('class').indexOf('gapline') > 0;
        duration = Math.min(parseInt(20 * length), 4000);
        if (isgap) {
          duration = 250;
          el = $(path).css({
            'transition-property': 'opacity',
            'transition-duration': duration + 'ms',
            'transition-delay': delay + 'ms',
            stroke: 'url(#' + gradId + ')',
            opacity: 0
          }).attr('class', 'weight pathline gapline');
          delay = delay - 25;
        } else {
          el = $(path).css({
            'stroke': 'url(#' + gradId + ')',
            'transition-property': 'stroke-dashoffset',
            'transition-duration': duration + 'ms',
            'transition-delay': delay + 'ms',
            'stroke-dasharray': length + 10,
            'stroke-dashoffset': length + 10
          }).attr('class', 'weight pathline');
          delay = delay + duration;
        }
      }
      timeoutSet(300, function() {
        return container.addClass('showing');
      });
      return timeoutSet(400, function() {
        var len6, q, results;
        results = [];
        for (p = q = 0, len6 = draw.length; q < len6; p = ++q) {
          path = draw[p];
          results.push(el = $(path).css({
            'stroke-dashoffset': 0,
            'opacity': 1
          }));
        }
        return results;
      });
    };

    HelixHelpers.prototype.loadBrainLine = function(graph) {
      var day, json_url;
      if (graph.hasClass('drawn')) {
        return;
      }
      day = graph.parents('.day');
      if (day.css('display') === 'none') {
        return;
      }
      json_url = graph.attr('data-url');
      if (!json_url) {
        return;
      }
      return this.buildBrainGraph(graph, json_url);
    };

    HelixHelpers.prototype.buildBrainGraph = function(container, json_url) {
      return d3.json(json_url, (function(_this) {
        return function(error, response) {
          if (error) {
            console.warn(error);
          }
          if (response.items.length) {
            if (response.totals.total_seconds > 600) {
              _this.graphBrain(container, response.items);
              return _this.addBrainDetails(container, response.totals);
            } else {

            }
          } else {
            return console.log('no items for day');
          }
        };
      })(this));
    };

    HelixHelpers.prototype.addBrainDetails = function(container, totals) {
      var details, info;
      info = container.parents('.day').find('.day-info').first();
      if (info.hasClass('written')) {
        return;
      }
      details = info.find('.details').first();
      if (totals.total_seconds > 600) {
        details.append('<p class="online time">' + parseInt(totals.total_seconds / 3600) + ' hrs online</p>');
        if (totals.productive_seconds > 600) {
          details.append('<p class="productive time">' + totals.ratio + '% productive</p>');
        }
      }
      return timeoutSet(50, function() {
        return info.addClass('written');
      });
    };

    HelixHelpers.prototype.graphBrain = function(container, items) {
      var area, bottomArea, commit_points, downLine, end, height, hour, i, id, len, line, max_commits, max_music, max_seconds, midpoint, min_commits, min_music, min_seconds, music_points, productiveFill, productive_points, start, svg, totalFill, total_points, unproductiveFill, unproductive_points, width, x, y_commits, y_music, y_prod, y_total, y_unprod;
      width = container.width();
      height = container.height();
      midpoint = height * 0.5;
      if ($('#device-info').hasClass('desktop')) {
        midpoint = height * 0.55;
      }
      max_seconds = 60 * 60 * 2.8;
      min_seconds = 0;
      max_music = 20;
      min_music = 0;
      max_commits = 10;
      min_commits = 0;
      start = items[0].start;
      end = start + (1440 * 60 * 1000) - (60 * 60 * 1000);
      id = container.attr('id');
      svg = d3.select('#' + id).select('svg');
      line = d3.svg.line().interpolate('basis').x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      downLine = d3.svg.line().interpolate('basis').x(function(d) {
        return d.x;
      }).y(function(d) {
        return midpoint - (d.y - midpoint);
      });
      area = d3.svg.area().interpolate('basis').x(function(d) {
        return d.x;
      }).y0(midpoint).y1(function(d) {
        return d.y;
      });
      bottomArea = d3.svg.area().interpolate('basis').x(function(d) {
        return d.x;
      }).y1(midpoint).y0(function(d) {
        return midpoint - (d.y - midpoint);
      });
      totalFill = 'totalFill' + id;
      productiveFill = 'productiveFill' + id;
      unproductiveFill = 'unproductiveFill' + id;
      svg.append('linearGradient').attr('id', totalFill).attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
        {
          offset: '10%',
          color: 'rgba(90,120,160,0.4)'
        }, {
          offset: '70%',
          color: 'rgba(90,120,160,0.2)'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      svg.append('linearGradient').attr('id', productiveFill).attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
        {
          offset: '50%',
          color: '#1d9e32'
        }, {
          offset: '80%',
          color: '#ddff3d'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      svg.append('linearGradient').attr('id', 'productiveStroke').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
        {
          offset: '35%',
          color: 'rgba(80,170,50,0.0)'
        }, {
          offset: '44%',
          color: 'rgba(70,205,35,0.3)'
        }, {
          offset: '75%',
          color: 'rgba(70,205,35,0.9)'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      svg.append('linearGradient').attr('id', 'unproductiveStroke').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
        {
          offset: '35%',
          color: 'rgba(255,60,50,0.0)'
        }, {
          offset: '44%',
          color: 'rgba(255,150,50,0.7)'
        }, {
          offset: '75%',
          color: 'rgba(255,40,80,0.9)'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      svg.append('linearGradient').attr('id', unproductiveFill).attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
        {
          offset: '20%',
          color: '#ba1a1a'
        }, {
          offset: '50%',
          color: '#ffa811'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      productive_points = [];
      total_points = [];
      unproductive_points = [];
      commit_points = [];
      music_points = [];
      for (i = 0, len = items.length; i < len; i++) {
        hour = items[i];
        x = (hour.start - start) / (end - start);
        y_prod = (max_seconds - hour.productive_seconds) / (max_seconds - min_seconds);
        y_unprod = (max_seconds - hour.unproductive_seconds) / (max_seconds - min_seconds);
        y_total = (max_seconds - hour.total_seconds) / (max_seconds - min_seconds);
        y_music = (max_music - hour.total_songs) / (max_music - min_music);
        y_commits = (max_commits - hour.total_commits) / (max_commits - min_commits);
        productive_points.push({
          "x": x * width,
          "y": y_prod * height - (height - midpoint)
        });
        unproductive_points.push({
          "x": x * width,
          "y": y_unprod * height - (height - midpoint)
        });
        total_points.push({
          "x": x * width,
          "y": y_total * height - (height - midpoint)
        });
      }
      if (total_points.length) {
        svg.append('path').attr('d', area(productive_points)).attr('class', 'patharea productive').style('fill', 'url(#' + productiveFill + ')');
        svg.append('path').attr('d', line(productive_points)).attr('class', 'pathline productive');
        svg.append('path').attr('d', bottomArea(unproductive_points)).attr('class', 'patharea unproductive').style('fill', 'url(#' + unproductiveFill + ')');
        svg.append('path').attr('d', line(unproductive_points)).attr('class', 'pathline unproductive');
        svg.append('path').attr('d', line(total_points)).attr('class', 'pathline total');
      }
      return timeoutSet(50, function() {
        return container.addClass('drawn');
      });
    };

    HelixHelpers.prototype.loadHeartLine = function(graph) {
      var day, json_url;
      if (graph.hasClass('drawn')) {
        return;
      }
      day = graph.parents('.day');
      if (day.css('display') === 'none') {
        return;
      }
      json_url = graph.attr('data-url');
      if (!json_url) {
        return;
      }
      return this.buildHeartGraph(graph, json_url);
    };

    HelixHelpers.prototype.buildHeartGraph = function(graph, json_url) {
      return d3.json(json_url, (function(_this) {
        return function(error, response) {
          if (error) {
            console.warn(error);
          }
          if (response.heartrates && response.heartrates.length) {
            _this.graphHeartrates(graph, response.heartrates, response.start, response.end, response.chunked, response.max, response.min);
            _this.addMaxMin(graph, response.max, response.min);
            return _this.addHeartMaxMin(graph, response.max, response.min);
          } else {
            _this.addMaxMin(graph, 0, 0);
            return console.log('no items for day');
          }
        };
      })(this));
    };

    HelixHelpers.prototype.graphHeartrates = function(container, items, start, end, chunked, max, min) {
      var avg, chunk, coloring, count, dark, delay, draw, duration, el, even, first, gaps, gradId, heartrates, height, hr, hrg, i, id, j, k, l, latest_gapline, len, len1, len2, len3, len4, len5, length, line, m, newHr, o, p, path, points, ref, ref1, sport, sum, svg, width, x, y;
      height = container.height();
      width = container.width();
      dark = true;
      min = 0;
      max = 240;
      line = d3.svg.line().interpolate('basis').x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      id = container.attr('id');
      svg = d3.select('#page #' + id).select('svg');
      gaps = [];
      first = true;
      even = true;
      sport = false;
      if (chunked) {
        for (i = 0, len = items.length; i < len; i++) {
          chunk = items[i];
          points = [];
          for (j = 0, len1 = chunk.length; j < len1; j++) {
            heartrates = chunk[j];
            x = (heartrates.time - start) / (end - start);
            count = heartrates.values.length;
            if (count) {
              sum = 0;
              ref = heartrates.values;
              for (k = 0, len2 = ref.length; k < len2; k++) {
                hr = ref[k];
                sum += parseInt(hr);
              }
              avg = parseInt(sum / count);
              y = (max - avg) / (max - min);
            }
            if (x && y) {
              points.push({
                "x": x * width,
                "y": y * height
              });
            }
            if (first && x > (sport ? 0.2 : 0.03)) {
              newHr = {
                time: start,
                values: [sport ? 120 : 60]
              };
              gaps.push(newHr);
              first = false;
            }
          }
          if (!first) {
            gaps.push(chunk[0]);
          }
          gaps.push(chunk[chunk.length - 1]);
          first = false;
          svg.append('path').attr('d', line(points)).attr('class', 'pathline');
        }
      }
      even = false;
      latest_gapline = [];
      for (l = 0, len3 = gaps.length; l < len3; l++) {
        hrg = gaps[l];
        if (hrg && hrg.time) {
          x = (hrg.time - start) / (end - start);
          count = hrg.values.length;
          if (count) {
            sum = 0;
            ref1 = hrg.values;
            for (m = 0, len4 = ref1.length; m < len4; m++) {
              hr = ref1[m];
              sum += parseInt(hr);
            }
            avg = parseInt(sum / count);
            y = (max - avg) / (max - min);
          }
          if (y) {
            latest_gapline.push({
              x: x * width,
              y: y * height
            });
            if (even) {
              svg.append('path').attr('d', line(latest_gapline)).attr('class', 'gapline');
              latest_gapline = [];
              even = false;
            } else {
              even = true;
            }
          }
        }
      }
      gradId = 'heartLine' + id;
      coloring = svg.append('linearGradient').attr('id', gradId).attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0);
      coloring.selectAll('stop').data([
        {
          offset: '18%',
          color: '#25822c'
        }, {
          offset: '28%',
          color: 'rgba(65,130,140,0.6)'
        }, {
          offset: '44%',
          color: 'rgba(50,100,125,0.7)'
        }, {
          offset: '56%',
          color: '#ffc835'
        }, {
          offset: '80%',
          color: '#ff355b'
        }
      ]).enter().append('stop').attr('offset', function(d) {
        return d.offset;
      }).attr('stop-color', function(d) {
        return d.color;
      });
      draw = $('path', container);
      delay = 50;
      for (p = o = 0, len5 = draw.length; o < len5; p = ++o) {
        path = draw[p];
        length = parseInt(path.getTotalLength());
        duration = Math.max(parseInt(6.4 * length), 320);
        el = $(path).css({
          'stroke': 'url(#' + gradId + ')',
          'transition-property': 'stroke-dashoffset',
          'transition-duration': duration + 'ms',
          'transition-delay': delay + 'ms',
          'stroke-dasharray': length + 10,
          'stroke-dashoffset': length + 10
        });
        delay = delay + duration;
      }
      timeoutSet(120, function() {
        return container.addClass('drawn');
      });
      return timeoutSet(400, function() {
        var len6, q, results;
        results = [];
        for (p = q = 0, len6 = draw.length; q < len6; p = ++q) {
          path = draw[p];
          results.push(el = $(path).css({
            'stroke-dashoffset': 0
          }));
        }
        return results;
      });
    };

    HelixHelpers.prototype.addMaxMin = function(graph, max, min) {
      var info, section;
      section = graph.parents('.section');
      info = section.children('.section-info');
      if (max && min) {
        info.addClass('populated');
        if (max === min) {
          $('.max', info).parent().text('Heart rate was around ' + max + ' bpm');
        } else {
          $('.max', info).text(max);
          $('.min', info).text(min);
        }
        if (max < 140) {
          return section.addClass('low');
        }
      } else {
        return info.addClass('empty');
      }
    };

    HelixHelpers.prototype.addHeartMaxMin = function(container, max, min) {
      var info, maxEl, minEl;
      info = container.parents('.day').find('.day-info');
      maxEl = $('.max', info).html('Peak: <span class="value">' + max + ' bpm</span>');
      minEl = $('.min', info).html('Rest: <span class="value">' + min + ' bpm</span>');
      if (max > 120) {
        maxEl.addClass('high');
      }
      if (max > 170) {
        maxEl.addClass('very-high');
      }
      if (min < 65) {
        minEl.addClass('low');
      }
      if (min < 45) {
        minEl.addClass('very-low');
      }
      return info.addClass('written');
    };

    return HelixHelpers;

  })();

  window.HelixHome = (function() {
    function HelixHome(helpers) {
      this.helpers = helpers;
    }

    HelixHome.prototype.init = function() {
      this.helpers.loadHeartLine($('#page .heartline'));
      this.helpers.loadBrainLine($('#page .brainline'));
      this.helpers.loadWeightLine($('#page .weightline'));
      return this.revealSections();
    };

    HelixHome.prototype.revealSections = function() {
      return $('#page .home-content .section').each(function(n, el) {
        var initial, section;
        section = $(el);
        initial = 750;
        if ($('html').hasClass('mobile')) {
          initial = 100;
        }
        return timeoutSet(initial + 180 * n, function() {
          return section.addClass('showing');
        });
      });
    };

    HelixHome.prototype.cleanup = function() {
      return console.log('cleanup...');
    };

    HelixHome.prototype.canSwitchDay = function() {
      return $('body').hasClass('loaded');
    };

    HelixHome.prototype.switchDay = function(amount) {
      var goto, nav;
      if (this.scrollLock) {
        return;
      }
      nav = $('.page .day-nav');
      if (!nav.length) {
        return;
      }
      if (amount < 0) {
        goto = nav.find('.previous');
      } else if (amount > 0) {
        goto = nav.find('.next');
      }
      if (goto.length) {
        return goto.click();
      }
    };

    return HelixHome;

  })();

  window.HelixLegs = (function() {
    function HelixLegs(helpers) {
      this.helpers = helpers;
    }

    HelixLegs.prototype.init = function() {
      return this.drawStepsLine();
    };

    HelixLegs.prototype.drawStepsLine = function() {
      var bars, container;
      container = $('#page #fitnessmonth');
      bars = $('#page .month-day .steps-bar');
      return this.helpers.buildStepsLine(container, bars);
    };

    return HelixLegs;

  })();

  stuff = (function() {
    function stuff() {}

    stuff.prototype.graphWeight = function() {
      var graph, json_url;
      graph = $('.page .big-graph .line');
      json_url = graph.attr('data-url');
      if (!json_url) {
        return;
      }
      return d3.json(json_url, (function(_this) {
        return function(error, json) {
          if (error) {
            console.warn(error);
          }
          if (json.items.length) {
            return _this.graphLine(json.items, graph);
          }
        };
      })(this));
    };

    stuff.prototype.graphLine = function(data, graph) {
      var averages, datum, draw, end, height, i, j, len, len1, length, line1, line2, max, min, n, path, points, ref, start, svg, width, x, xAxis, y, yAxis;
      graph.removeClass('showing');
      width = graph.width();
      height = graph.height();
      max = d3.max(data, function(d) {
        return d.pounds;
      });
      min = d3.min(data, function(d) {
        return d.pounds;
      });
      min = Math.max(0, parseInt(min - 0.25));
      max = parseInt(max + 1);
      start = new Date(data[data.length - 1].time);
      end = new Date(data[0].time);
      points = [];
      averages = [];
      ref = data.reverse();
      for (n = i = 0, len = ref.length; i < len; n = ++i) {
        datum = ref[n];
        x = (datum.time - start) / (end - start);
        y = (datum.pounds - max) / (min - max);
        points.push({
          "x": x * width,
          "y": y * height
        });
        if (n > 4) {
          averages.push({
            "y": (points[n].y + points[n - 1].y + points[n - 2].y + points[n - 3].y) / 4,
            "x": x * width
          });
        } else {
          averages.push({
            "x": x * width,
            "y": points[n].y
          });
        }
      }
      line1 = d3.svg.line().interpolate('linear').x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      line2 = d3.svg.line().interpolate('basis').x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      svg = d3.select('#page .big-graph .line').append('svg').attr('class', 'graph big-core-graph');
      svg.append('path').attr('d', line1(points));
      svg.append('path').attr('d', line2(averages));
      draw = $('path', graph);
      for (j = 0, len1 = draw.length; j < len1; j++) {
        path = draw[j];
        length = path.getTotalLength();
        $(path).css({
          'stroke-dasharray': length + 10,
          'stroke-dashoffset': length + 10
        });
      }
      xAxis = $('.page .x.axis');
      yAxis = $('.page .y.axis');
      this.fillAxis(xAxis, start, end, 'time');
      this.fillAxis(yAxis, min, max, 'pounds');
      return timeoutSet(50, function() {
        return graph.addClass('showing');
      });
    };

    stuff.prototype.fillAxis = function(element, min, max, units) {
      var max_value, mid, mid_value, min_value;
      element.empty();
      if (units === 'time') {
        mid = max.valueOf() + min.valueOf();
        mid = new Date(mid / 2);
        min_value = min.getMonth() + 1 + '/' + min.getDate();
        max_value = max.getMonth() + 1 + '/' + max.getDate();
        mid_value = mid.getMonth() + 1 + '/' + mid.getDate();
      } else {
        mid = parseInt((max + min) / 2);
        min_value = min + ' ' + units;
        mid_value = mid + ' ' + units;
        max_value = max + ' ' + units;
      }
      element.append('<span class="min tick">' + min_value + '</span>').append('<span class="max tick">' + max_value + '</span>');
      if (mid_value) {
        return element.append('<span class="mid tick">' + mid_value + '</span>');
      }
    };

    stuff.prototype.buildDays = function() {
      var initial, labels, preloaded;
      preloaded = $('.page-container').hasClass('scanned');
      initial = preloaded ? -180 : 1200;
      labels = $('.heart-timelines .day-labels');
      timeoutSet(200 + initial, function() {
        return labels.addClass('showing');
      });
      return $('.page .days .day').each((function(_this) {
        return function(n, el) {
          var day, graphs, json_url;
          day = $(el);
          timeoutSet(initial + 400 + 320 + n * 480, function() {
            return day.addClass('showing');
          });
          graphs = $('.graphs', day);
          json_url = graphs.attr('data-url');
          if (!json_url) {
            return;
          }
          return _this.buildGraphsForDay(graphs, json_url, n, initial);
        };
      })(this));
    };

    stuff.prototype.buildGraphsForDay = function(graphs, json_url, n, initial_delay) {
      return d3.json(json_url, (function(_this) {
        return function(error, response) {
          if (error) {
            console.warn(error);
          }
          if (response.heartrates.length) {
            timeoutSet(initial_delay + 20 + n * 480, function() {
              return _this.graphHeartrates(graphs, response.heartrates, response.start_time);
            });
            return _this.addMinMax(graphs, response.max, response.min);
          } else {
            return console.log('no items for day');
          }
        };
      })(this));
    };

    stuff.prototype.addMinMax = function(container, max, min) {
      var bounds;
      console.log(max, min);
      bounds = container.parents('.day').find('.bounds');
      $('.max .value', bounds).text(max);
      $('.min .value', bounds).text(min);
      if (max > 120) {
        $('.max', bounds).addClass('high');
      }
      if (max > 170) {
        $('.max', bounds).addClass('very-high');
      }
      if (min < 65) {
        $('.min', bounds).addClass('low');
      }
      return bounds.addClass('showing');
    };

    stuff.prototype.graphHeartrates = function(container, data, start_time) {
      var avg, chunk, delay, draw, duration, el, end, fn, gradId, heartrates, height, hr, i, id, j, k, l, len, len1, len2, len3, length, line, max, maxhr, min, minhr, p, path, points, ref, results, start, sum, svg, width, x, y;
      width = container.width();
      height = container.height();
      max = 200;
      min = 25;
      start = start_time;
      end = parseInt(start_time) + 60 * 60 * 24 * 1000;
      line = d3.svg.line().interpolate('basis').x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      id = container.attr('id');
      svg = d3.select('#page #' + id).select('svg');
      for (i = 0, len = data.length; i < len; i++) {
        chunk = data[i];
        points = [];
        maxhr = false;
        minhr = false;
        for (j = 0, len1 = chunk.length; j < len1; j++) {
          heartrates = chunk[j];
          x = (heartrates.time - start) / (end - start);
          if (heartrates.values.length) {
            sum = 0;
            ref = heartrates.values;
            for (k = 0, len2 = ref.length; k < len2; k++) {
              hr = ref[k];
              sum += parseInt(hr.bpm);
            }
            avg = parseInt(sum / heartrates.values.length);
            maxhr = Math.max(avg, maxhr);
            minhr = minhr || avg;
            minhr = Math.min(avg, minhr);
            y = (max - avg) / (max - min);
          }
          if (avg && x && y) {
            points.push({
              "x": x * width,
              "y": y * height
            });
          }
        }
        if (points.length) {
          svg.append('linearGradient').attr('id', 'heartLine' + id).attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', height).attr('x2', 0).attr('y2', 0).selectAll('stop').data([
            {
              offset: '10%',
              color: '#25822c'
            }, {
              offset: '23%',
              color: '#206068'
            }, {
              offset: '36%',
              color: '#1a3747'
            }, {
              offset: '52%',
              color: '#ffc835'
            }, {
              offset: '70%',
              color: '#ff355b'
            }
          ]).enter().append('stop').attr('offset', function(d) {
            return d.offset;
          }).attr('stop-color', function(d) {
            return d.color;
          });
          svg.append('path').attr('d', line(points)).attr('class', 'pathline');
        }
      }
      draw = $('.graph path', container);
      delay = 100;
      fn = function(path, p) {
        return timeoutSet(delay, (function(_this) {
          return function() {
            return $(path).css({
              'stroke-dashoffset': 0
            });
          };
        })(this));
      };
      results = [];
      for (p = l = 0, len3 = draw.length; l < len3; p = ++l) {
        path = draw[p];
        length = parseInt(path.getTotalLength());
        duration = Math.max(parseInt(4 * length), 150);
        gradId = 'heartLine' + id;
        el = $(path).css({
          'stroke': 'url(#' + gradId + ')',
          'transition-duration': duration + 'ms',
          'stroke-dasharray': length + 10,
          'stroke-dashoffset': length + 10
        });
        fn(path, p);
        results.push(delay = delay + duration);
      }
      return results;
    };

    stuff.prototype.fillAxis = function(element, min, max, units) {
      var max_value, mid, mid_value, min_value;
      element.empty();
      if (units === 'time') {
        mid = max.valueOf() + min.valueOf();
        mid = new Date(mid / 2);
        min_value = min.getMonth() + 1 + '/' + min.getDate();
        max_value = max.getMonth() + 1 + '/' + max.getDate();
        mid_value = mid.getMonth() + 1 + '/' + mid.getDate();
      } else {
        mid = parseInt((max + min) / 2);
        min_value = min + ' ' + units;
        mid_value = mid + ' ' + units;
        max_value = max + ' ' + units;
      }
      element.append('<span class="min tick">' + min_value + '</span>').append('<span class="max tick">' + max_value + '</span>');
      if (mid_value) {
        return element.append('<span class="mid tick">' + mid_value + '</span>');
      }
    };

    return stuff;

  })();

}).call(this);
